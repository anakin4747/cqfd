#!/usr/bin/env bash

# gen-cqfdrc - Interactive generator for .cqfdrc

# Define the schema
FIELDS=(
    "project:org"
    "project:name"
    "project:build_context"
    "project:custom_img_name"
    "build:command"
    "build:distro"
    "build:user_extra_groups"
    "build:docker_build_args"
    "build:docker_run_args"
    "build:docker_rmi_args"
    "build:files"
    "build:archive"
    "build:tar_transform"
    "build:tar_options"
    "next:NEW_SECTION_PROMPT"
)

# Store values
declare -A VALUES

# Current field index
IDX=0

# Initialize state tracking
FIRST_RUN="true"
PREV_IDX=0

# Function to calculate lines to move up
calculate_lines_to_move() {
    LINES_TO_MOVE=0
    local last_sect=""
    for ((i=0; i<=PREV_IDX; i++)); do
        local f=${FIELDS[$i]}
        local s=${f%%:*}
        local k=${f##*:}

        # Section header logic
        if [ "$s" != "$last_sect" ]; then
            if [ -n "$last_sect" ]; then ((LINES_TO_MOVE++)); fi # Empty line
            if [ "$k" != "NEW_SECTION_PROMPT" ]; then
                ((LINES_TO_MOVE++)) # Section header
            fi
            last_sect=$s
        fi

        # Field line logic
        if [ $i -eq $PREV_IDX ] || [ -n "${VALUES[$f]}" ]; then
            ((LINES_TO_MOVE++))
        fi
    done
}

# Function to clear screen and print current state
print_state() {
    if [ "$FIRST_RUN" != "true" ]; then
        calculate_lines_to_move

        # Move cursor up
        if [ $LINES_TO_MOVE -gt 1 ]; then
            tput cuu $((LINES_TO_MOVE - 1))
        fi
        tput cr

        # Clear from cursor to end of screen
        tput ed
    fi

    FIRST_RUN="false"
    PREV_IDX=$IDX

    local last_section=""

    # Loop through all fields up to current
    for ((i=0; i<=IDX; i++)); do
        local field=${FIELDS[$i]}
        local section=${field%%:*}
        local key=${field##*:}

        # Print section header if changed
        if [ "$section" != "$last_section" ]; then
            if [ -n "$last_section" ]; then echo ""; fi
            if [ "$key" != "NEW_SECTION_PROMPT" ]; then
                echo "[$section]"
            fi
            last_section=$section
        fi

        # If it's the current field being edited
        if [ $i -eq $IDX ]; then
            if [ "$key" == "NEW_SECTION_PROMPT" ]; then
                printf "["
            else
                printf "%s=" "$key"
            fi
        else
            # Print previously entered value if it exists
            local val=${VALUES[$field]}
            if [ -n "$val" ]; then
                if [ "$key" != "NEW_SECTION_PROMPT" ]; then
                    echo "$key=$val"
                fi
            fi
        fi
    done
}

# Main loop
while [ $IDX -lt ${#FIELDS[@]} ]; do
    # Handle going back from 0
    if [ $IDX -lt 0 ]; then IDX=0; fi

    print_state

    CURRENT_FIELD=${FIELDS[$IDX]}

    # Check if we are prompting for a new section
    if [[ "$CURRENT_FIELD" == *":NEW_SECTION_PROMPT" ]]; then
        BUFFER=""
        printf "%s" "$BUFFER"

        while true; do
            IFS= read -rsn1 char

            if [[ -z "$char" ]]; then
                # Enter
                if [ -n "$BUFFER" ]; then
                    # User entered a new section name
                    NEW_SECTION="$BUFFER"

                    # Add standard build fields for this new section
                    NEW_FIELDS=(
                        "$NEW_SECTION:command"
                        "$NEW_SECTION:distro"
                        "$NEW_SECTION:user_extra_groups"
                        "$NEW_SECTION:docker_build_args"
                        "$NEW_SECTION:docker_run_args"
                        "$NEW_SECTION:docker_rmi_args"
                        "$NEW_SECTION:files"
                        "$NEW_SECTION:archive"
                        "$NEW_SECTION:tar_transform"
                        "$NEW_SECTION:tar_options"
                        "next:NEW_SECTION_PROMPT"
                    )

                    # Insert into FIELDS array
                    TEMP_FIELDS=("${FIELDS[@]:0:$IDX}")
                    TEMP_FIELDS+=("${NEW_FIELDS[@]}")
                    FIELDS=("${TEMP_FIELDS[@]}")

                    break
                else
                    # Empty input -> Stop adding sections
                    ((IDX++))
                    break
                fi
            elif [[ "$char" == $'\x7f' ]] || [[ "$char" == $'\x08' ]]; then
                # Backspace
                if [ ${#BUFFER} -gt 0 ]; then
                    BUFFER="${BUFFER%?}"
                    printf "\b \b"
                fi
            elif [[ "$char" =~ [a-zA-Z0-9_-] ]]; then
                 BUFFER+="$char"
                 printf "%s" "$char"
            fi
        done

        continue
    fi

    # Get existing value to edit
    BUFFER="${VALUES[$CURRENT_FIELD]}"

    printf "%s" "$BUFFER"

    while true; do

        IFS= read -rsn1 char

        # Handle Enter (empty char)
        if [[ -z "$char" ]]; then
            # Save
            if [ -n "$BUFFER" ]; then
                VALUES[$CURRENT_FIELD]="$BUFFER"
            else
                unset VALUES["$CURRENT_FIELD"]
            fi
            ((IDX++))
            break
        fi

        # Handle Control Characters
        printf -v hex "%x" "'$char"

        if [[ "$hex" == "7f" ]] || [[ "$hex" == "8" ]]; then
            # Backspace
            if [ ${#BUFFER} -gt 0 ]; then
                BUFFER="${BUFFER%?}"
                printf "\b \b"
            fi
        elif [[ "$hex" == "e" ]]; then
            # Ctrl-N (Next)
            if [ -n "$BUFFER" ]; then
                VALUES[$CURRENT_FIELD]="$BUFFER"
            else
                unset VALUES["$CURRENT_FIELD"]
            fi
            ((IDX++))
            break
        elif [[ "$hex" == "10" ]]; then
            # Ctrl-P (Prev)
            if [ -n "$BUFFER" ]; then
                VALUES[$CURRENT_FIELD]="$BUFFER"
            else
                unset VALUES["$CURRENT_FIELD"]
            fi
            ((IDX--))
            break
        elif [[ "$hex" == "3" ]]; then
            # Ctrl-C
            echo ""
            exit 1
        elif [[ "$hex" =~ ^[2-7]. ]]; then
            # Printable characters
            BUFFER+="$char"
            printf "%s" "$char"
        else
            # Other printable chars
            if [ $((16#$hex)) -ge 32 ] && [ $((16#$hex)) -ne 127 ]; then
                 BUFFER+="$char"
                 printf "%s" "$char"
            fi
        fi
    done
done

# Write to file
OUTFILE=".cqfdrc"
{
    last_section=""
    for field in "${FIELDS[@]}"; do
        section=${field%%:*}
        key=${field##*:}

        # Skip the prompt field
        if [ "$key" == "NEW_SECTION_PROMPT" ]; then
            continue
        fi

        val=${VALUES[$field]}

        if [ -n "$val" ]; then
            if [ "$section" != "$last_section" ]; then
                if [ -n "$last_section" ]; then echo ""; fi
                echo "[$section]"
                last_section=$section
            fi
            echo "$key=$val"
        fi
    done
} > "$OUTFILE"

# Clear previous output and show file content
if [ "$FIRST_RUN" != "true" ]; then
    calculate_lines_to_move

    if [ $LINES_TO_MOVE -gt 1 ]; then
        tput cuu $((LINES_TO_MOVE - 1))
    fi
    tput cr
    tput ed
fi

cat "$OUTFILE"
