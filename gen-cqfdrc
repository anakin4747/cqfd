#!/bin/bash

# gen-cqfdrc - Interactive generator for .cqfdrc

# Define the schema
FIELDS=(
    "project:org"
    "project:name"
    "project:build_context"
    "project:custom_img_name"
    "build:command"
    "build:distro"
    "build:user_extra_groups"
    "build:docker_build_args"
    "build:docker_run_args"
    "build:docker_rmi_args"
    "build:files"
    "build:archive"
    "build:tar_transform"
    "build:tar_options"
)

# Store values
declare -A VALUES

# Current field index
IDX=0

# Function to clear screen and print current state
print_state() {
    if [ "$FIRST_RUN" != "true" ]; then
        # Move up N lines
        local lines_to_move=0
        local last_sect=""
        for ((i=0; i<=PREV_IDX; i++)); do
            local f=${FIELDS[$i]}
            local s=${f%%:*}

            # Section header logic
            if [ "$s" != "$last_sect" ]; then
                if [ -n "$last_sect" ]; then ((lines_to_move++)); fi # Empty line
                ((lines_to_move++)) # Section header
                last_sect=$s
            fi

            # Field line logic
            if [ $i -eq $PREV_IDX ] || [ -n "${VALUES[$f]}" ]; then
                ((lines_to_move++))
            fi
        done

        # Move cursor up
        if [ $lines_to_move -gt 1 ]; then
            tput cuu $((lines_to_move - 1))
        fi
        tput cr

        # Clear from cursor to end of screen
        tput ed
    fi

    FIRST_RUN="false"
    PREV_IDX=$IDX

    local last_section=""

    # Loop through all fields up to current
    for ((i=0; i<=IDX; i++)); do
        local field=${FIELDS[$i]}
        local section=${field%%:*}
        local key=${field##*:}

        # Print section header if changed
        if [ "$section" != "$last_section" ]; then
            if [ -n "$last_section" ]; then echo ""; fi
            echo "[$section]"
            last_section=$section
        fi

        # If it's the current field being edited
        if [ $i -eq $IDX ]; then
            printf "%s=" "$key"
        else
            # Print previously entered value if it exists
            local val=${VALUES[$field]}
            if [ -n "$val" ]; then
                echo "$key=$val"
            fi
        fi
    done
}


# Initialize state tracking
FIRST_RUN="true"
PREV_IDX=0

# Main loop
while [ $IDX -lt ${#FIELDS[@]} ]; do
    # Handle going back from 0
    if [ $IDX -lt 0 ]; then IDX=0; fi

    print_state

    CURRENT_FIELD=${FIELDS[$IDX]}

    # Get existing value to edit
    BUFFER="${VALUES[$CURRENT_FIELD]}"

    printf "%s" "$BUFFER"

    while true; do
        IFS= read -rsn1 char

        # Handle Enter (empty char)
        if [[ -z "$char" ]]; then
            # Save
            if [ -n "$BUFFER" ]; then
                VALUES[$CURRENT_FIELD]="$BUFFER"
            else
                unset VALUES[$CURRENT_FIELD]
            fi
            ((IDX++))
            break
        fi

        # Handle Control Characters
        # We use hex representation to be safe
        printf -v hex "%x" "'$char"

        if [[ "$hex" == "7f" ]] || [[ "$hex" == "8" ]]; then
            # Backspace
            if [ ${#BUFFER} -gt 0 ]; then
                BUFFER="${BUFFER%?}"
                printf "\b \b"
            fi
        elif [[ "$hex" == "e" ]]; then
            # Ctrl-N (Next)
            if [ -n "$BUFFER" ]; then
                VALUES[$CURRENT_FIELD]="$BUFFER"
            else
                unset VALUES[$CURRENT_FIELD]
            fi
            ((IDX++))
            break
        elif [[ "$hex" == "10" ]]; then
            # Ctrl-P (Prev)
            if [ -n "$BUFFER" ]; then
                VALUES[$CURRENT_FIELD]="$BUFFER"
            else
                unset VALUES[$CURRENT_FIELD]
            fi
            ((IDX--))
            break
        elif [[ "$hex" == "3" ]]; then
            # Ctrl-C
            echo ""
            exit 1
        elif [[ "$hex" =~ ^[2-7]. ]]; then
            # Printable characters (roughly)
            # This regex is a bit loose, let's just trust it's printable if not control
            BUFFER+="$char"
            printf "%s" "$char"
        else
            # Other printable chars (digits, etc)
            # Hex for 'a' is 61.
            # Let's just accept everything that isn't a control char we handled
            # Check if it's a control char ( < 0x20 )
            if [ $((16#$hex)) -ge 32 ] && [ $((16#$hex)) -ne 127 ]; then
                 BUFFER+="$char"
                 printf "%s" "$char"
            fi
        fi
    done
done

# Write to file
OUTFILE=".cqfdrc"
{
    last_section=""
    for field in "${FIELDS[@]}"; do
        section=${field%%:*}
        key=${field##*:}
        val=${VALUES[$field]}

        if [ -n "$val" ]; then
            if [ "$section" != "$last_section" ]; then
                if [ -n "$last_section" ]; then echo ""; fi
                echo "[$section]"
                last_section=$section
            fi
            echo "$key=$val"
        fi
    done
} > "$OUTFILE"

# Clear previous output and show file content
if [ "$FIRST_RUN" != "true" ]; then
    # Move up N lines
    lines_to_move=0
    last_sect=""
    for ((i=0; i<=PREV_IDX; i++)); do
        f=${FIELDS[$i]}
        s=${f%%:*}
        if [ "$s" != "$last_sect" ]; then
            if [ -n "$last_sect" ]; then ((lines_to_move++)); fi
            ((lines_to_move++))
            last_sect=$s
        fi
        if [ $i -eq $PREV_IDX ] || [ -n "${VALUES[$f]}" ]; then
            ((lines_to_move++))
        fi
    done

    if [ $lines_to_move -gt 1 ]; then
        tput cuu $((lines_to_move - 1))
    fi
    tput cr
    tput ed
fi

cat "$OUTFILE"
